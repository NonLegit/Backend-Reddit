<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="utf-8">
    <title>JSDoc: Source: data_access/CommentRepository.js</title>

    <script src="scripts/prettify/prettify.js"> </script>
    <script src="scripts/prettify/lang-css.js"> </script>
    <!--[if lt IE 9]>
      <script src="//html5shiv.googlecode.com/svn/trunk/html5.js"></script>
    <![endif]-->
    <link type="text/css" rel="stylesheet" href="styles/prettify-tomorrow.css">
    <link type="text/css" rel="stylesheet" href="styles/jsdoc-default.css">
</head>

<body>

<div id="main">

    <h1 class="page-title">Source: data_access/CommentRepository.js</h1>

    



    
    <section>
        <article>
            <pre class="prettyprint source linenums"><code>const Repository = require("./repository");
const ObjectId = require("mongodb").ObjectId;
const APIFeatures = require("./apiFeatures");

class CommentRepository extends Repository {
  constructor({ Comment }) {
    super(Comment);
  }

  async addReply(parent, child) {
    await this.model.findByIdAndUpdate(parent, {
      $push: { replies: child },
      $inc: { repliesCount: 1 },
    });
  }
  // async createComment(data) {

  //     const doc = await this.model.create(data).populate("author");
  //     console.log(doc);
  //     return { success: true, doc: doc };

  // }

  async removeReply(parent, child) {
    await this.model.findByIdAndUpdate(parent, {
      $pull: { replies: child },
      $inc: { repliesCount: -1 },
    });
  }

  async updateText(id, text) {
    const comment = await this.model.findByIdAndUpdate(
      id,
      { text: text },
      {
        new: true,
        runValidators: true,
      }
    );

    return { success: true, doc: comment };
  }

  async deleteComment(id) {
    await this.model.findByIdAndUpdate(id, { isDeleted: true });
    //await this.model.findByIdAndDelete(id);
  }

  async commentTree(children, limit, depth, sort) {
    const comments = this.model
      .find({
        _id: { $in: children },
      })
      .sort({ [sort]: -1 });

    if (depth >= 0) {
      comments
        .populate({
          path: "replies",
          perDocumentLimit: limit,
          options: { depth, sort: { [sort]: -1 } },
          // transform: (doc) => {
          //   doc.author.profilePicture =
          //     `${process.env.BACKDOMAIN}/` + doc.author.profilePicture;
          //   doc.author.profileBackground =
          //     `${process.env.BACKDOMAIN}/` + doc.author.profileBackground;
          //   return doc;
          // },
        })
        .lean();
    }

    return await comments;
  }

  async getUserComments(userId, query, popOptions) {
    const features = new APIFeatures(
      this.model.find({
        author: userId,
        isDeleted: false,
      }),
      query
    )
      .filter()
      .sort()
      .limitFields()
      .paginate();
    // const doc = await features.query.explain();

    let doc = await features.query.populate({
      path: popOptions,
      options: { userComments: true },
    });
    return { success: true, doc: doc };
  }
  async getCommentwithAuthor(commentId) {
    try {
      // const doc = await features.query.explain();
      // const features = new APIFeatures(this.model.find({ _id: postId }), "");
      // let doc = await features.query;
      let doc = await this.model.findOne({ _id: commentId }).populate({
        path: "author",
        options: { getAuthor: true },
      });
      // console.log(doc[0].owner);
      if (!doc) return { success: false, error: mongoErrors.NOT_FOUND };
      return { success: true, doc: doc };
    } catch (err) {
      return { success: false };
    }
  }


   async getComment(commentId) {
    try {
      // const doc = await features.query.explain();
      // const features = new APIFeatures(this.model.find({ _id: postId }), "");
      // let doc = await features.query;
      let doc = await this.model.findOne({ _id: commentId });
      // console.log(doc[0].owner);
      if (!doc) return { success: false, error: mongoErrors.NOT_FOUND };
      return { success: true, doc: doc };
    } catch (err) {
      return { success: false };
    }
  }
  async updateVotesCount(commentId, newVotes) {
    try {
      let doc = await this.model.findByIdAndUpdate(commentId, {
        votes: newVotes,
      });
      if (!doc) return { success: false, error: mongoErrors.NOT_FOUND };
      return { success: true, doc: doc };
    } catch (err) {
      return { success: false, ...decorateError(err) };
    }
  }

  /**
   * Changes the modState of a post according to action only by the moderators of the subreddit
   * @param {string} commentId The ID of the post
   * @param {string} action The action to be performed
   * @returns {bool} returns true if the action is performed successfully and false otherwise
   */
  async modAction(commentId, action) {
    //Just to be consistent with the language rules
    const state = action === "spam" ? "spammed" : action + "d";

    const doc = await this.model.findOneAndUpdate(
      { _id: commentId, modState: { $ne: state } },
      { modState: state },
      {
        new: true,
        runValidators: true,
      }
    );
    
    if (doc) return true;
    return false;
  }

  async search(q, page, limit) {
    const skip = (page - 1) * limit;

    const query = this.model
      .find({ $text: { $search: q }})
      .select("_id post text createdAt votes repliesCount")
      .populate({path: "post",select:"-sharedFrom", match: {ownerType: "Subreddit"}})
      .skip(skip)
      .limit(limit)
      .sort({score: { $meta: "textScore" }})
      .lean();

    const result = await query;
    return result;
  }
}
module.exports = CommentRepository;
</code></pre>
        </article>
    </section>




</div>

<nav>
    <h2><a href="index.html">Home</a></h2><h3>Classes</h3><ul><li><a href="AuthenticationController.html">AuthenticationController</a></li><li><a href="CommentService.html">CommentService</a></li><li><a href="FileController.html">FileController</a></li><li><a href="PostService.html">PostService</a></li><li><a href="UserController.html">UserController</a></li><li><a href="UserService.html">UserService</a></li><li><a href="subredditService.html">subredditService</a></li></ul>
</nav>

<br class="clear">

<footer>
    Documentation generated by <a href="https://github.com/jsdoc/jsdoc">JSDoc 4.0.0</a> on Fri Dec 23 2022 23:46:52 GMT+0200 (Eastern European Standard Time)
</footer>

<script> prettyPrint(); </script>
<script src="scripts/linenumber.js"> </script>
</body>
</html>
